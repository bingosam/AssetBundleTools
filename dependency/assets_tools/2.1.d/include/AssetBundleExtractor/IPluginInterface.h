#pragma once
#include "..\AssetsTools\AssetsFileFormat.h"
#include "..\AssetsTools\AssetsBundleFileFormat.h"
#include "..\AssetsTools\AssetsFileReader.h"
#include "..\AssetsTools\AssetsReplacer.h"
#include "..\AssetsTools\AssetTypeClass.h"

class IAssetInterface
{
public:
	//Gets the class id of the asset
	virtual int GetClassID()=0;
	//Gets the index of the asset class inside MonoManager (only if the class id is < 0); for format >= 0x0D
	virtual unsigned short GetMonoClassID()=0;

	//Returns the path id of the asset
	virtual __int64 GetPathID()=0;
	//Returns the absolute file id of the asset
	virtual int GetFileID()=0;
	//Returns the absolute file id of a referenced file id from an asset (usually in PPtrs)
	virtual int GetAbsoluteFileID(int referenceFileID)=0;

	//Returns a pointer to the current AssetsFile instance
	virtual AssetsFile *GetAssetsFile()=0;
	
	//Returns a UTF-8 file path string
	virtual const char *GetAssetsFileBasePath()=0;

	//Returns a UTF-8 string
	virtual const char *GetAssetsFileName()=0;

	//Gets the file reader and reader param and returns the file size.
	virtual unsigned __int64 GetFileReader(AssetsFileReader &reader, LPARAM &readerPar, unsigned __int64 &filePos)=0;
	
	//Frees a file reader returned by GetFileReader; Only use this BEFORE calling AddReplacer
	virtual void FreeFileReader(AssetsFileReader reader, LPARAM readerPar)=0;
};
class IPluginInterface
{
public:
	//Returns a pointer to the AssetsFile instance by an absolute file id (or NULL if it doesn't exist)
	virtual AssetsFile *GetAssetsFileByFileID(int fileID)=0;

	//Returns a pointer to the AssetsBundleFile by its name (usually CAB_<16byte hash>) (or NULL if it doesn't exist)
	virtual AssetsBundleFile *GetBundleFileByName(const char *bundleName, size_t strLen = 0)=0;
	//Returns a pointer to the current bundle file
	virtual AssetsBundleFile *GetBundleFile()=0;
	virtual FILE *GetBundleFileFile()=0;
	
	//Open a streamed asset (in a .resources or .resS file that contains audio and/or texture data or possibly more in following Unity versions)
	virtual bool OpenStreamedData(const char *name, QWORD offset, QWORD length, AssetsFileReader &reader, LPARAM &readerPar)=0;
	virtual void CloseStreamedData(LPARAM dataPar)=0;

	//Adds an AssetsReplacer. It needs to be created with one of the functions in AssetsReplacer.h. The application frees it.
	//If it replaces an asset referred to by the asset interface/s passed to the plugin, 
	//the asset interface's reader can't longer be relied on as it might be freed.
	virtual void AddReplacer(AssetsReplacer *pReplacer)=0;
	
	//Makes a template type of the classID using type information from the assets file or from one of the class databases.
	virtual bool MakeTemplateField(AssetsFile *pAssetsFile, int classID, AssetTypeTemplateField *pTemplateBase, WORD scriptIndex = 0xFFFF)=0;

	//returns the id of a class by its name
	virtual int GetClassByName(AssetsFile *pAssetsFile, const char *name)=0;

	//Get the type name from a class id as UTF-8 or UTF-16 from type information or one of the class databases;
	//if none is found, returns the hexadecimal string of classID
	virtual void GetTypenameA(AssetsFile *pAssetsFile, int classID, char *nameBuffer, unsigned int bufferLen)=0;
	virtual void GetTypenameW(AssetsFile *pAssetsFile, int classID, wchar_t *nameBuffer, unsigned int bufferLen)=0;
	
	//Shows a file open dialog.
	virtual HRESULT ShowFileOpenDialog(HWND hOwner, WCHAR **filePathBuf, wchar_t *fileTypeFilter, LPCTSTR defaultFile = NULL)=0;
	//Shows a file save dialog.
	virtual HRESULT ShowFileSaveDialog(HWND hOwner, WCHAR **filePathBuf, const wchar_t *fileTypeFilter, LPCTSTR defaultFile = NULL)=0;
	//Shows a file folder select dialog.
	virtual BOOL ShowFolderSelectDialog(HWND hOwner, WCHAR **folderPathBuf, LPCWSTR windowTitle = NULL)=0;
	//Frees a file dialog string (generated by the UTF-16 versions only).
	virtual void FreeCOMFilePathBuf(WCHAR **filePathBuf)=0;

	//Uses ShowFolderSelectDialog, converts the folder path to UTF-8 and returns that value
	virtual BOOL ShowFolderSelectDialogA(HWND hOwner, CHAR **folderPathBuf, size_t *folderPathLen, LPCWSTR windowTitle = NULL)=0;
	//Frees a UTF-8 file dialog string (generated by the UTF-8 versions only).
	virtual void FreeUTF8DialogBuf(CHAR **filePathBuf)=0;

	//Creates a filename for batch export (i.e. assetName "test" and extension ".jpg" -> "test.jpg");
	//also checks for duplicates and adds numbers if necessary; if assetName is null or empty, uses <fileId>_<pathId> instead
	//May return NULL when out of memory after showing a MessageBox
	virtual char *MakeExportFileName(char *outFolder, const char *assetName, int fileId, __int64 pathId, char **previousFileNames, size_t index, size_t count, const char *extension)=0;
	//Like MakeExportFileName but converts the returned string to UTF-16
	virtual WCHAR *MakeExportFileNameW(char *outFolder, const char *assetName, int fileId, __int64 pathId, char **previousFileNames, size_t index, size_t count, const char *extension)=0;
	//Frees strings returned by MakeExportFileName and MakeExportFileNameW
	virtual void MemFree(void *buf)=0;
	
	virtual FILE *fopenUTF8(const char *fileName, const char *mode)=0;
	virtual errno_t fopenUTF8_s(FILE** ppFile, const char *fileName, const char *mode)=0;
};

//The function type of the plugin callback.
typedef void(_cdecl *AssetPluginCallback)(HWND hParentWnd, IPluginInterface *pInterface, IAssetInterface **ppAssets, size_t count);
//The function type of the plugin's function that returns a PluginInfo pointer. The function should be exported with a .def file as GetAssetBundlePluginInfo.
typedef struct PluginInfo*(_cdecl *AssetPlugin_GetPluginInfoCallback)();

enum PluginAction
{
	PluginAction_IMPORT,
	PluginAction_EXPORT,
	PluginAction_IMPORT_Batch, //not supported
	PluginAction_EXPORT_Batch
};
struct PluginAssetOption
{
	char desc[256]; //Plugin option description as shown in the Plugins dialog.
	int unityClassID; //Class ID of the supported type.
	PluginAction action; //Type of action.
	AssetPluginCallback callback; //Plugin function to be called to perform the action.
};
//A PluginInfo structure pointer is expected to be returned by the plugin's GetAssetBundlePluginInfo function.
//Should be written to a buffer with sizeof(PluginInfo)+optionCount*sizeof(PluginAssetOption) Bytes, the buffer should not be reused or freed after the GetAssetBundlePluginInfo call.
struct PluginInfo
{
	char name[64]; //Name of the Plugin; not actually used at the moment.
	unsigned int optionCount; //Amount of plugin options.
	PluginAssetOption options[0]; //Variable-size array for the plugin options.
};